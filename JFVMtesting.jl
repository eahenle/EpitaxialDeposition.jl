### A Pluto.jl notebook ###
# v0.18.1

using Markdown
using InteractiveUtils

# ╔═╡ d6b3a9fa-3c6d-422d-afff-30e49502e145
begin
	import Pkg; using Pkg
	Pkg.add(url="https://github.com/simulkade/JFVMvis.jl")
	Pkg.add(url="https://github.com/simulkade/JFVM.jl")
	Pkg.add("PyPlot")
	Pkg.add("CairoMakie")
end

# ╔═╡ d2eb8940-9b16-11ec-1d74-3bc00f5f950f
using JFVM, JFVMvis, CairoMakie

# ╔═╡ 7c259d4c-122c-4270-ad64-185b09be4a2f
begin
	# Start by generating a uniform mesh, defined on the size of the domain and number of cells in each direction

	# Non-uniform meshes can be generated by defining an array of "cell positions" and passing it into `createMesh1D` instead of Nx and Lx
	
	Nx = 40 # number of cells in x direction
	Ny = 60 # numbers of cells in y direction
	Lx = 1.0 # [cm] - domain length in x direction
	Ly = 3.0 # [cm] - domain length in y direction

	N_steps = 100
	
	m = createMesh2D(Nx, Ny, Lx, Ly) # generate a uniform mesh (2D)

end

# ╔═╡ 96eb56ba-82e4-40ba-a973-7e00a3b3a65f
BC = createBC(m)

# ╔═╡ 6a944590-be5a-498f-aaf0-8966f610dc61
function trans_diff_dirichlet(m::MeshStructure; N=N_steps)

	# Define our boundary conditions. Package/function defaults yield Neumann boundary conditions, though Dirichlet and Robin conditions are also supported, and each cell face can have a unique boundary condition
	BC = createBC(m)

	# left and right boundary conditions for each coefficient in the boundary condition expression 
	
	#link: https://nbviewer.org/github/simulkade/JFVM.jl/blob/master/examples/jfvm_tutorial.ipynb
	BC.left.a[:] .= 0.0 
	BC.right.a[:] .= 0.0

	BC.left.b[:] .= 1.0
	BC.right.b[:] .= 1.0

	BC.left.c[:] .= 1.0 
	BC.right.c[:] .= 0.0

	# top and bottom boundary conditions for each coefficient
	BC.top.a[1,:] .= 1.0 
	BC.bottom.a[1,:] .= 1.0

	BC.top.b[1,:] .= 1.0 
	BC.bottom.b[1,:] .= 1.0

	BC.top.c[1,:] .= 1.0 
	BC.bottom.c[1,:] .= 1.0 
		

	# Give a value for the diffusion coefficient
	D = 0.01 # [cm²/s]
	D_cell = createCellVariable(m, D) # assign the diffusion coefficient as a variable to each cell
	D_face = geometricMean(D_cell) # choose an averaging scheme, for how the average diffusion coefficient on a cell face is calculated

	# Initialize the value of concentration
	c₀ = 1.5 # [mol/L]
	
	c = createCellVariable(m, c₀, BC) # assign the "initial" concentration to cells
	
	# Discretize the problem and build our solution
	M_diff = diffusionTerm(D_face) # matrix of diffusion term coefficients
	(M_bc, RHS_bc) = boundaryConditionTerm(BC) # matrix composed of coefficients and the right hand side for the BC

		
	Δt = sqrt(Lx^2 / D) / N # recommended time step calculation -- UNITS???

	# this code seems to be for taking discrete time steps forward, with size of Δt
	for i = 1:2
		(M_t, RHS_t) = transientTerm(c, Δt, 1.0)
		M = M_t - M_diff + M_bc # adding together all sparse matrices of coefficients
		RHS = RHS_bc + RHS_t # add all RHS's to each other
		c = solveLinearPDE(m, M, RHS)
	end

return c

end

# ╔═╡ d1c1b8cd-8488-497a-b1dc-ffa3007b32e4
sol = trans_diff_dirichlet(m)

# ╔═╡ 66bf8ff3-3cf4-4725-94a7-e0473778dbd6
sol.value

# ╔═╡ 71f69688-8a77-44df-bcc7-d5c07362a9c7
begin

	fig = CairoMakie.Figure()
	ax = Axis(fig[1,1],
				xlabel = "x-direction",
				ylabel = "y-direction",
				title = "Concentration Profile *PLOTS CELLS NOT TRUE LENGTHS*")
		
	heatmap!(sol.value)

	Colorbar(fig[1,2], limits = (0, maximum(sol.value)), colormap = :viridis,
			label = "Concentration [mol/L]")

	fig

end

# ╔═╡ Cell order:
# ╠═d6b3a9fa-3c6d-422d-afff-30e49502e145
# ╠═d2eb8940-9b16-11ec-1d74-3bc00f5f950f
# ╠═7c259d4c-122c-4270-ad64-185b09be4a2f
# ╠═96eb56ba-82e4-40ba-a973-7e00a3b3a65f
# ╠═6a944590-be5a-498f-aaf0-8966f610dc61
# ╠═d1c1b8cd-8488-497a-b1dc-ffa3007b32e4
# ╠═66bf8ff3-3cf4-4725-94a7-e0473778dbd6
# ╠═71f69688-8a77-44df-bcc7-d5c07362a9c7

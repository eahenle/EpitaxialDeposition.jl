### A Pluto.jl notebook ###
# v0.18.1

using Markdown
using InteractiveUtils

# ╔═╡ d6b3a9fa-3c6d-422d-afff-30e49502e145
begin
	import Pkg; using Pkg
	Pkg.add(url="https://github.com/simulkade/JFVMvis.jl")
	Pkg.add(url="https://github.com/simulkade/JFVM.jl")
	Pkg.add("PyPlot")
	Pkg.add("CairoMakie")
end

# ╔═╡ d2eb8940-9b16-11ec-1d74-3bc00f5f950f
using JFVM, JFVMvis, CairoMakie

# ╔═╡ 7c259d4c-122c-4270-ad64-185b09be4a2f
begin
	# Start by generating a uniform mesh, defined on the size of the domain and number of cells in each direction

	# Non-uniform meshes can be generated by defining an array of "cell positions" and passing it into `createMesh1D` instead of Nx and Lx
	
	Nx = 20 # number of cells in x direction
	Ny = 30
	Lx = 1.0 # [m] - domain length in x direction
	Ly = 3.0 # [m]

	N_steps = 100
	
	m = createMesh2D(Nx, Ny, Lx, Ly) # uniform mesh (2D)

end

# ╔═╡ 96eb56ba-82e4-40ba-a973-7e00a3b3a65f
BC = createBC(m)

# ╔═╡ 00da229b-0101-41ac-ba44-b9cdd2732dc3


# ╔═╡ 6a944590-be5a-498f-aaf0-8966f610dc61
function trans_diff_dirichlet(m::MeshStructure; N=N_steps)

	# Define our boundary conditions. Package/function defaults yield Neumann boundary conditions, though Dirichlet and Robin conditions are also supported, and each cell face can have a unique boundary condition
	BC = createBC(m)

	# left and right boundary conditions for each coefficient in the boundary condition expression 
	
	#link: https://nbviewer.org/github/simulkade/JFVM.jl/blob/master/examples/jfvm_tutorial.ipynb
	BC.left.a[:] .= 0.0 
	BC.right.a[:] .= 0.0

	BC.left.b[:] .= 12.0
	BC.right.b[:] .= 12.0

	BC.left.c[:] .= 5.0 
	BC.right.c[:] .= 0.0

	# top and bottom boundary conditions for each coefficient
	BC.top.a[1,:] .= 1.0 
	BC.bottom.a[1,:] .= 1.0

	BC.top.b[1,:] .= 1.0 
	BC.bottom.b[1,:] .= 1.0

	BC.top.c[1,:] .= 1.0 
	BC.bottom.c[1,:] .= 1.0 
		

	
	
	# Give a value for the diffusion coefficient
	D = 12 # units?
	D_cell = createCellVariable(m, D) # assign the diffusion coefficient as a variable to each cell
	D_face = geometricMean(D_cell) # choose an averaging scheme, for how the average diffusion coefficient on a cell face is calculated

	# Initialize the value of concentration
	c₀ = 6.0
	c_old = createCellVariable(m, c₀, BC)
	
	# Discretize the problem and build our solution
	M_diff = diffusionTerm(D_face) # matrix of diffusion term coefficients
	(M_bc, RHS_bc) = boundaryConditionTerm(BC) # matrix composed of coefficients and the right hand side for the BC

		
	Δt = sqrt(Lx^2 / D) / N # recommended time step calculation -- UNITS???

	
	for i = 1:2
		(M_t, RHS_t) = transientTerm(c_old, Δt, 1.0)
		M = M_t - M_diff + M_bc # adding together all sparse matrices of coefficients
		RHS = RHS_bc + RHS_t # add all RHS's to each other
		c_old = solveLinearPDE(m, M, RHS)
	end

return c_old

end

# ╔═╡ d1c1b8cd-8488-497a-b1dc-ffa3007b32e4
c = trans_diff_dirichlet(m)

# ╔═╡ 24333f47-3978-4986-a32f-fbddf24f162a
visualizeCells(c) # visualization function doesn't work

# ╔═╡ 66bf8ff3-3cf4-4725-94a7-e0473778dbd6
c.value

# ╔═╡ b37779dd-c303-48ab-9348-48f9bb6290af
size(c.value)

# ╔═╡ 71f69688-8a77-44df-bcc7-d5c07362a9c7
begin

	fig = CairoMakie.Figure()
	ax = Axis(fig[1,1],
				xlabel = "x-direction",
				ylabel = "y-direction",
				title = "Concentration Profile")
		
	heatmap!(c.value)

	Colorbar(fig[1,2], limits = (0, maximum(c.value)), colormap = :viridis,
			label = "Concentration [mol/L]")

	fig

end

# ╔═╡ Cell order:
# ╠═d6b3a9fa-3c6d-422d-afff-30e49502e145
# ╠═d2eb8940-9b16-11ec-1d74-3bc00f5f950f
# ╠═7c259d4c-122c-4270-ad64-185b09be4a2f
# ╠═96eb56ba-82e4-40ba-a973-7e00a3b3a65f
# ╠═00da229b-0101-41ac-ba44-b9cdd2732dc3
# ╠═6a944590-be5a-498f-aaf0-8966f610dc61
# ╠═d1c1b8cd-8488-497a-b1dc-ffa3007b32e4
# ╠═24333f47-3978-4986-a32f-fbddf24f162a
# ╠═66bf8ff3-3cf4-4725-94a7-e0473778dbd6
# ╠═b37779dd-c303-48ab-9348-48f9bb6290af
# ╠═71f69688-8a77-44df-bcc7-d5c07362a9c7

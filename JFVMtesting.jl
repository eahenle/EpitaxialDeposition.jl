### A Pluto.jl notebook ###
# v0.18.1

using Markdown
using InteractiveUtils

# ╔═╡ d6b3a9fa-3c6d-422d-afff-30e49502e145
begin
	import Pkg; using Pkg
	Pkg.add(url="https://github.com/simulkade/JFVMvis.jl")
	Pkg.add(url="https://github.com/simulkade/JFVM.jl")
	Pkg.add("PyPlot")
	Pkg.add("CairoMakie")
end

# ╔═╡ d2eb8940-9b16-11ec-1d74-3bc00f5f950f
using JFVM, JFVMvis, CairoMakie

# ╔═╡ 7c259d4c-122c-4270-ad64-185b09be4a2f
begin
	# Start by generating a uniform mesh, defined on the size of the domain and number of cells in each direction

	# Non-uniform meshes can be generated by defining an array of "cell positions" and passing it into `createMesh1D` instead of Nx and Lx
	
	Nx = 20 # number of cells in x direction
	Ny = 10
	Lx = 5.0 # [m] - domain length in x direction
	Ly = 1.0 

	N_steps = 20
	
	m = createMesh2D(Nx, Ny, Lx, Ly) # uniform mesh (2D)

end

# ╔═╡ 6a944590-be5a-498f-aaf0-8966f610dc61
function trans_diff_dirichlet(m::MeshStructure; N=N_steps)

	# Define our boundary conditions. Package/function defaults yield Neumann boundary conditions, though Dirichlet and Robin conditions are also supported, and each cell face can have a unique boundary condition
	BC = createBC(m)
	
	BC.left.a[:] = BC.right.a[:] .= 0.0

	BC.left.b[:] = BC.right.b[:] .= 1.0

	BC.left.c[:] .= 1.0 

	BC.right.c[:] .= 0.0
	
	# Give a value for the diffusion coefficient
	D = 1 # units?
	D_cell = createCellVariable(m, D) # assign the diffusion coefficient as a variable to each cell
	D_face = geometricMean(D_cell) # choose an averaging scheme, for how the average diffusion coefficient on a cell face is calculated

	# Initialize the value of concentration
	c₀ = 0.0
	c_old = createCellVariable(m, c₀, BC)
	
	# Discretize the problem and build our solution
	M_diff = diffusionTerm(D_face) # matrix of diffusion term coefficients
	(M_bc, RHS_bc) = boundaryConditionTerm(BC) # matrix composed of coefficients and the right hand side for the BC

		
	Δt = sqrt(Lx^2 / D) / N # recommended time step calculation -- UNITS???

	
	for i = 1:5
		(M_t, RHS_t) = transientTerm(c_old, Δt, 1.0)
		M = M_t - M_diff + M_bc # adding together all sparse matrixes of coefficients
		RHS = RHS_bc + RHS_t # add all RHS's to each other
		c_old = solveLinearPDE(m, M, RHS)
	end

return c_old

end

# ╔═╡ d1c1b8cd-8488-497a-b1dc-ffa3007b32e4
c = trans_diff_dirichlet(m)

# ╔═╡ 24333f47-3978-4986-a32f-fbddf24f162a
visualizeCells(c) # visualization function doesn't work

# ╔═╡ 66bf8ff3-3cf4-4725-94a7-e0473778dbd6
c.value

# ╔═╡ 3262ca19-5727-4520-85ea-4a5e9d9f3810
c.value[:, 1]

# ╔═╡ b37779dd-c303-48ab-9348-48f9bb6290af
size(c.value)

# ╔═╡ 71f69688-8a77-44df-bcc7-d5c07362a9c7
begin

	fig = CairoMakie.Figure()
	ax = Axis(fig[1,1],
				xlabel = "",
				ylabel = "",
				title = "")

	# for i = 1:size(c.value)[1]


	# 	for j = 1:size(c.value)[2]
			
			
			
	# 	end
		
	# end
	xlims!(0, Lx)
	ylims!(0, Ly)
	contourf!(c.value, levels = 0.1:0.1:1)

	Colorbar(fig[1,2])
	fig

end

# ╔═╡ Cell order:
# ╠═d6b3a9fa-3c6d-422d-afff-30e49502e145
# ╠═d2eb8940-9b16-11ec-1d74-3bc00f5f950f
# ╠═7c259d4c-122c-4270-ad64-185b09be4a2f
# ╠═6a944590-be5a-498f-aaf0-8966f610dc61
# ╠═d1c1b8cd-8488-497a-b1dc-ffa3007b32e4
# ╠═24333f47-3978-4986-a32f-fbddf24f162a
# ╠═66bf8ff3-3cf4-4725-94a7-e0473778dbd6
# ╠═3262ca19-5727-4520-85ea-4a5e9d9f3810
# ╠═b37779dd-c303-48ab-9348-48f9bb6290af
# ╠═71f69688-8a77-44df-bcc7-d5c07362a9c7
